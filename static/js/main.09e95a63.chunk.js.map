{"version":3,"sources":["services/request.js","constants.js","stores/raidsStore.js","stores/index.js","App.js","hooks/useStores.jsx","serviceWorker.js","index.js"],"names":["client","axios","create","baseURL","request","options","params","api_key","then","response","console","debug","data","catch","error","config","status","headers","message","Promise","reject","RaidsStore","raidsToGetFightsFor","parsesByRaider","zones","loading","loadingBracketParses","loadingOverallParses","loadingZones","timeRemaining","medianBracket","bestBracket","medianOverall","bestOverall","healerTypes","healerExclusionList","healers","updateWhenFinished","reaction","log","Date","now","start","Object","keys","sort","forEach","raider","bestBracketRow","name","medianBracketRow","bestOverallRow","medianOverallRow","bracket","bossKey","boss","average","parses","percentile","length","Number","isInteger","best","toFixed","isNaN","overall","push","localStorage","setItem","JSON","stringify","previouslyGrabbedRaids","parse","getItem","this","raidCutoff","weeks","parseCutoff","url","raidsById","values","raid","end","dayOfWeek","getDay","id","zone","needToGetData","includes","requests","raidId","all","spread","responses","fightsToGetRaidersFrom","title","fight","exportedCharacters","char","friendlyData","friendlies","find","e","type","bracketRequests","raiders","secondsRemaining","Math","floor","i","setTimeout","metric","overallRequests","bracketResponses","characterName","encounter","encounterID","startTime","errors","overallResponses","decorate","observable","storesContext","React","createContext","raidStore","App","observer","useContext","getParseColor","value","color","generateTable","bwl","encounters","rows","row","avg","count","style","borderCollapse","map","d","key","padding","textAlign","fontWeight","backgroundColor","border","margin","join","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.09e95a63.chunk.js","sourcesContent":["import axios from \"axios\";\nimport { url } from \"constants.js\";\n\nconst client = axios.create({\n  baseURL: url,\n});\n\n/**\n * Request Wrapper with default success/error actions\n */\nconst request = function (options) {\n  const onSuccess = function (response) {\n    console.debug(\"Request Successful!\", response);\n    return response.data;\n  };\n\n  const onError = function (error) {\n    console.error(\"Request Failed:\", error.config);\n\n    // log response data if it exists\n    if (error.response) {\n      console.error(\"Status:\", error.response.status);\n      console.error(\"Data:\", error.response.data);\n      console.error(\"Headers:\", error.response.headers);\n    } else {\n      console.error(\"Error Message:\", error.message);\n    }\n\n    return Promise.reject(error.response || error.message);\n  };\n\n  // add the api_key to each request\n  options.params = { ...options.params, api_key: \"ce3902772ae4b70c973b6a9f54f844fd\" };\n\n  return client(options).then(onSuccess).catch(onError);\n};\n\nexport default request;\n","const url = 'https://classic.warcraftlogs.com:443/v1/';\n\nexport {\n    url\n};","import { decorate, observable, reaction } from \"mobx\";\nimport axios from \"axios\";\nimport request from \"services/request\";\n\nconst weekInNanoSeconds = 7 * 24 * 60 * 60 * 1000;\nconst Wednesday = 3;\nconst Thursday = 4;\nconst weeks = 4;\nconst requestDelay = 2000;\n\nclass RaidsStore {\n  raidsToGetFightsFor = [];\n  parsesByRaider = {};\n  zones = {};\n\n  loading = true;\n  loadingBracketParses = true;\n  loadingOverallParses = true;\n  loadingZones = true;\n  error = \"\";\n  timeRemaining = 0;\n\n  medianBracket = [];\n  bestBracket = [];\n  medianOverall = [];\n  bestOverall = [];\n\n  healerTypes = [\"Priest\", \"Paladin\", \"Druid\"];\n  healerExclusionList = [\"Lightsaber\", \"Neku\", \"Taede\"];\n  healers = [];\n  start;\n\n  constructor() {\n    const previouslyGrabbedRaids = JSON.parse(localStorage.getItem(\"previousRaids\"));\n    this.parsesByRaider = JSON.parse(localStorage.getItem(\"parsesByRaider\")) ?? {};\n    console.log(this.parsesByRaider[\"Zero\"]);\n\n    this.start = Date.now();\n    const raidCutoff = this.start - weeks * weekInNanoSeconds;\n    const parseCutoff = this.start - 6 * weekInNanoSeconds;\n\n    request({ url: \"/zones\" }).then((response) => {\n      this.zones = response;\n      this.loadingZones = false;\n    });\n\n    request({\n      url: \"/reports/guild/RIVAL/Fairbanks/US\",\n    }).then((response) => {\n      const raidsById = {};\n\n      Object.values(response).forEach((raid) => {\n        const duration = raid.end - raid.start;\n\n        if (duration > 0) {\n          const dayOfWeek = new Date(raid.start).getDay();\n          raidsById[raid.id] = raid;\n          if (raid.start > raidCutoff && (dayOfWeek === Wednesday || dayOfWeek === Thursday) && raid.zone === 1002) {\n            this.raidsToGetFightsFor.push(raid.id);\n          }\n        }\n      });\n\n      let needToGetData = false;\n\n      if (!previouslyGrabbedRaids) {\n        needToGetData = true;\n      } else {\n        this.raidsToGetFightsFor.forEach((id) => {\n          if (!previouslyGrabbedRaids.includes(id)) {\n            needToGetData = true;\n          }\n        });\n      }\n\n      if (needToGetData) {\n        const requests = [];\n        this.raidsToGetFightsFor.forEach((raidId) => {\n          requests.push(request({ url: `/report/fights/${raidId}` }));\n        });\n\n        axios.all(requests).then(\n          axios.spread((...responses) => {\n            const fightsToGetRaidersFrom = [];\n            Object.values(raidsById).forEach((raid) => {\n              responses.forEach((response) => {\n                if (raid.start === response.start && raid.title === response.title) {\n                  fightsToGetRaidersFrom.push(response);\n                }\n              });\n            });\n\n            fightsToGetRaidersFrom.forEach((fight) => {\n              fight.exportedCharacters.forEach((char) => {\n                const friendlyData = fight.friendlies.find((e) => e.name === char.name);\n                console.log(friendlyData);\n                if (\n                  this.healerTypes.includes(friendlyData.type) &&\n                  !this.healerExclusionList.includes(friendlyData.name) &&\n                  !this.healers.includes(friendlyData.name)\n                ) {\n                  this.healers.push(friendlyData.name);\n                }\n                this.parsesByRaider[char.name] = {};\n              });\n            });\n\n            //send parse requests for bracket parses delayed between each other to prevent api lockout\n            const bracketRequests = [];\n            const raiders = Object.keys(this.parsesByRaider);\n\n            const secondsRemaining = Math.floor(((raiders.length + 3) * requestDelay) / 1000);\n            this.timeRemaining = secondsRemaining;\n            for (let i = 0; i < secondsRemaining; i++) {\n              setTimeout(() => {\n                this.timeRemaining = this.timeRemaining - 1;\n              }, i * 1000);\n            }\n\n            for (let i = 0; i < raiders.length; i++) {\n              setTimeout(() => {\n                const raider = raiders[i];\n                bracketRequests.push(\n                  request({\n                    url: `/parses/character/${raider}/Fairbanks/US`,\n                    params: { bracket: -1, metric: this.healers.includes(raider) ? \"hps\" : \"dps\" },\n                  })\n                );\n              }, requestDelay * i);\n            }\n\n            const overallRequests = [];\n            for (let i = 0; i < raiders.length; i++) {\n              setTimeout(() => {\n                const raider = raiders[i];\n                overallRequests.push(\n                  request({\n                    url: `/parses/character/${raider}/Fairbanks/US`,\n                    params: { metric: this.healers.includes(raider) ? \"hps\" : \"dps\" },\n                  })\n                );\n              }, requestDelay * i);\n            }\n\n            setTimeout(() => {\n              axios\n                .all(bracketRequests)\n                .then(\n                  axios.spread((...bracketResponses) => {\n                    bracketResponses.forEach((response) => {\n                      if (response[0]) {\n                        const name = response[0].characterName;\n                        this.parsesByRaider[name].bracket = {};\n\n                        response.forEach((encounter) => {\n                          const { bracket } = this.parsesByRaider[name];\n                          if (!bracket[encounter.encounterID]) {\n                            bracket[encounter.encounterID] = {\n                              best: 0,\n                              parses: [],\n                            };\n                          }\n\n                          if (encounter.startTime > parseCutoff) {\n                            bracket[encounter.encounterID].parses.push(encounter.percentile);\n                          }\n\n                          if (bracket[encounter.encounterID].best < encounter.percentile) {\n                            bracket[encounter.encounterID].best = encounter.percentile;\n                          }\n                        });\n                      }\n                    });\n                    this.loadingBracketParses = false;\n                  })\n                )\n                .catch((errors) => {\n                  this.error =\n                    \"There were too many requests made recently to WarcraftLogs. Try again in like 10 minutes to allow my api key to becoming unlocked and then try re-loading the page.\";\n                  this.loadingBracketParses = false;\n                });\n            }, raiders.length * requestDelay);\n\n            setTimeout(() => {\n              axios\n                .all(overallRequests)\n                .then(\n                  axios.spread((...overallResponses) => {\n                    overallResponses.forEach((response) => {\n                      if (response[0]) {\n                        const name = response[0].characterName;\n                        this.parsesByRaider[name].overall = {};\n\n                        response.forEach((encounter) => {\n                          const { overall } = this.parsesByRaider[name];\n                          if (!overall[encounter.encounterID]) {\n                            overall[encounter.encounterID] = {\n                              best: 0,\n                              parses: [],\n                            };\n                          }\n\n                          if (encounter.startTime > parseCutoff) {\n                            overall[encounter.encounterID].parses.push(encounter.percentile);\n                          }\n\n                          if (overall[encounter.encounterID].best < encounter.percentile) {\n                            overall[encounter.encounterID].best = encounter.percentile;\n                          }\n                        });\n                      }\n                    });\n                    this.loadingOverallParses = false;\n                  })\n                )\n                .catch((errors) => {\n                  this.error =\n                    \"There were too many requests made recently to WarcraftLogs. Try again in like 10 minutes to allow my api key to becoming unlocked and then try re-loading the page.\";\n                  this.loadingOverallParses = false;\n                });\n            }, (raiders.length + 2) * requestDelay);\n          })\n        );\n      } else {\n        this.loadingBracketParses = false;\n        this.loadingOverallParses = false;\n      }\n    });\n  }\n\n  updateWhenFinished = reaction(\n    () => this.loadingBracketParses || this.loadingOverallParses || this.loadingZones,\n    () => {\n      if (!this.loadingBracketParses && !this.loadingOverallParses && !this.loadingZones) {\n        console.log(\"done loading, time elapsed: \", Date.now() - this.start);\n\n        const raiders = Object.keys(this.parsesByRaider).sort();\n        raiders.forEach((raider) => {\n          const bestBracketRow = { name: raider };\n          const medianBracketRow = { name: raider };\n          const bestOverallRow = { name: raider };\n          const medianOverallRow = { name: raider };\n\n          const { bracket } = this.parsesByRaider[raider];\n          if (bracket) {\n            Object.keys(bracket).forEach((bossKey) => {\n              const boss = bracket[bossKey];\n              let average = 0;\n              boss.parses.forEach((percentile) => {\n                average += percentile;\n              });\n              average /= boss.parses.length;\n              bestBracketRow[bossKey] = Number.isInteger(boss.best) ? boss.best : boss.best.toFixed(2);\n              medianBracketRow[bossKey] = Number.isNaN(average)\n                ? \"-\"\n                : Number.isInteger(average)\n                ? average\n                : average.toFixed(2);\n            });\n          }\n\n          const { overall } = this.parsesByRaider[raider];\n          if (overall) {\n            Object.keys(overall).forEach((bossKey) => {\n              const boss = overall[bossKey];\n              let average = 0;\n              boss.parses.forEach((percentile) => {\n                average += percentile;\n              });\n              average /= boss.parses.length;\n              bestOverallRow[bossKey] = Number.isInteger(boss.best) ? boss.best : boss.best.toFixed(2);\n              medianOverallRow[bossKey] = Number.isNaN(average)\n                ? \"-\"\n                : Number.isInteger(average)\n                ? average\n                : average.toFixed(2);\n            });\n          }\n\n          this.bestBracket.push(bestBracketRow);\n          this.medianBracket.push(medianBracketRow);\n          this.bestOverall.push(bestOverallRow);\n          this.medianOverall.push(medianOverallRow);\n        });\n\n        this.loading = false;\n        localStorage.setItem(\"previousRaids\", JSON.stringify(this.raidsToGetFightsFor));\n        localStorage.setItem(\"parsesByRaider\", JSON.stringify(this.parsesByRaider));\n      }\n    }\n  );\n}\n\ndecorate(RaidsStore, {\n  error: observable,\n  healers: observable,\n  loading: observable,\n  loadingBracketParses: observable,\n  loadingOverallParses: observable,\n  timeRemaining: observable,\n  loadingZones: observable,\n  bestBracket: observable,\n  medianBracket: observable,\n  bestOverall: observable,\n  medianOverall: observable,\n  zones: observable,\n});\n\nexport default RaidsStore;\n","import React from \"react\";\nimport RaidsStore from \"./raidsStore\";\n\nexport const storesContext = React.createContext({\n  raidStore: new RaidsStore(),\n});\n","import React from \"react\";\nimport { observer } from \"mobx-react\";\nimport { useStores } from \"hooks/useStores\";\n\nconst App = observer(() => {\n  const { raidStore } = useStores();\n\n  const getParseColor = (value) => {\n    let color = \"black\";\n    if (value === 100) {\n      color = \"#F4D03F\";\n    } else if (value >= 95 && value < 100) {\n      color = \"#F39C12\";\n    } else if (value >= 75 && value < 95) {\n      color = \"#8E44AD\";\n    } else if (value >= 50 && value < 75) {\n      color = \"#3498DB\";\n    } else if (value >= 25 && value < 50) {\n      color = \"#2ECC71\";\n    } else if (value >= 0 && value < 25) {\n      color = \"#BDC3C7\";\n    }\n    return color;\n  };\n\n  const generateTable = (data) => {\n    const bwl = raidStore.zones.find((zone) => zone.id === 1002);\n    // generate header row\n    const headers = [\"Raider\", \"Average\"];\n    bwl.encounters.forEach((encounter) => {\n      headers.push(encounter.name);\n    });\n\n    const rows = [];\n    data.forEach((raider) => {\n      const row = [raider.name];\n      const encounters = [];\n      let avg = 0;\n      let count = 0;\n      bwl.encounters.forEach((encounter) => {\n        const value = raider[encounter.id];\n\n        if (value && value !== \"-\") {\n          avg += Number(value);\n          count += 1;\n        }\n        encounters.push(value ?? \"-\");\n      });\n\n      if (avg !== 0) {\n        row.push((avg / count).toFixed(2));\n        encounters.forEach((encounter) => row.push(encounter));\n        rows.push(row);\n      }\n    });\n\n    return (\n      <table style={{ borderCollapse: \"collapse\" }}>\n        <thead>\n          <tr>\n            {headers.map((d) => (\n              <th\n                key={d}\n                style={{\n                  padding: \"5px\",\n                  textAlign: \"left\",\n                  fontWeight: \"bold\",\n                  backgroundColor: \"#5D6D7E\",\n                  color: \"white\",\n                  border: \"1px solid black\",\n                }}\n              >\n                {d}\n              </th>\n            ))}\n          </tr>\n        </thead>\n\n        <tbody>\n          {rows.map((row) => (\n            <tr>\n              {row.map((d) => (\n                <td style={{ padding: \"0px 5px\", border: \"1px solid black\", color: `${getParseColor(d)}` }}>{d}</td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    );\n  };\n\n  return (\n    <div>\n      {raidStore.loading ? (\n        <div>\n          <p style={{ margin: \"5px\" }}>Due to WarcraftLog's API request limit, loading will take about 2 minutes.</p>\n          {raidStore.timeRemaining > 0 && (\n            <p style={{ margin: \"5px\" }}>{`Estimated time remaining: ${raidStore.timeRemaining}s`}</p>\n          )}\n        </div>\n      ) : raidStore.error !== \"\" ? (\n        `ERROR: ${raidStore.error}`\n      ) : (\n        <div>\n          <p\n            style={{ margin: \"5px\" }}\n          >{`Druids, Paladins, and Priests have healing parses pulled. The following people are excluded from that: ${raidStore.healerExclusionList\n            .sort()\n            .join(\", \")}`}</p>\n          <br />\n          <p style={{ margin: \"5px\" }}>Median Bracket (last 6 weeks of parses):</p>\n          {generateTable(raidStore.medianBracket)}\n          <p>Best Bracket:</p>\n          {generateTable(raidStore.bestBracket)}\n          <p>Median Overall (last 6 weeks of parses):</p>\n          {generateTable(raidStore.medianOverall)}\n          <p>Best Overall:</p>\n          {generateTable(raidStore.bestOverall)}\n        </div>\n      )}\n    </div>\n  );\n});\n\nexport default App;\n","import React from 'react'\nimport { storesContext } from 'stores'\n\nexport const useStores = () => React.useContext(storesContext);","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}