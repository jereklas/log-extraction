{"version":3,"sources":["services/request.js","constants.js","stores/raidsStore.js","stores/index.js","App.js","hooks/useStores.jsx","serviceWorker.js","index.js"],"names":["client","axios","create","baseURL","request","options","params","api_key","then","response","console","debug","data","catch","error","config","status","headers","message","Promise","reject","storageId","lastSeenRaids","parsesByRaider","Object","freeze","RaidsStore","raidsToGetFightsFor","zones","loading","loadingBracketParses","loadingOverallParses","loadingZones","needToGetData","timeRemaining","medianBracket","bestBracket","medianOverall","bestOverall","healerTypes","healerExclusionList","healers","isRaidDataOutOfDate","JSON","parse","localStorage","getItem","length","forEach","id","includes","findRaiders","responses","raidFights","raids","raid","start","title","push","fight","exportedCharacters","char","friendlyData","friendlies","find","e","name","type","handleParseRequests","requests","raiders","loadingVariableName","parseCutoff","setTimeout","all","spread","characterName","encounter","parses","encounterID","numberOfEncounters","best","startTime","percentile","finalizeParseData","reaction","log","Date","now","keys","sort","raider","bracket","overall","getBossParseData","bracketMedian","bracketBest","overallMedian","overallBest","setItem","stringify","this","url","zone","z","filter","map","raidId","secondsRemaining","Math","floor","i","bracketRequests","overallRequests","metric","partitions","median","bossKey","boss","average","Number","isInteger","toFixed","isNaN","decorate","observable","storesContext","React","createContext","raidStore","App","observer","useContext","getParseColor","value","color","generateTable","encounters","rows","row","avg","count","style","borderCollapse","margin","d","key","padding","textAlign","fontWeight","backgroundColor","border","getPartitionName","join","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a415a2d7.chunk.js","sourcesContent":["import axios from \"axios\";\nimport { url } from \"constants.js\";\n\nconst client = axios.create({\n  baseURL: url,\n});\n\n/**\n * Request Wrapper with default success/error actions\n */\nconst request = function (options) {\n  const onSuccess = function (response) {\n    console.debug(\"Request Successful!\", response);\n    return response.data;\n  };\n\n  const onError = function (error) {\n    console.error(\"Request Failed:\", error.config);\n\n    // log response data if it exists\n    if (error.response) {\n      console.error(\"Status:\", error.response.status);\n      console.error(\"Data:\", error.response.data);\n      console.error(\"Headers:\", error.response.headers);\n    } else {\n      console.error(\"Error Message:\", error.message);\n    }\n\n    return Promise.reject(error.response || error.message);\n  };\n\n  // add the api_key to each request\n  options.params = { ...options.params, api_key: \"ce3902772ae4b70c973b6a9f54f844fd\" };\n\n  return client(options).then(onSuccess).catch(onError);\n};\n\nexport default request;\n","const url = 'https://classic.warcraftlogs.com:443/v1/';\n\nexport {\n    url\n};","import { decorate, observable, reaction } from \"mobx\";\nimport axios from \"axios\";\nimport request from \"services/request\";\n\nconst weekInNanoSeconds = 7 * 24 * 60 * 60 * 1000;\nconst requestDelay = 2000;\nconst zoneToGatherParsesFrom = \"Temple of Ahn'Qiraj\";\n// const zoneToGatherParsesFrom = \"Blackwing Lair\";\nconst apiError =\n  \"There were too many requests made recently to WarcraftLogs. Try again in like 10 minutes to allow my api key to becoming unlocked and then try re-loading the page.\";\nconst partition = 2;\n\nconst storageId = {\n  lastSeenRaids: \"previousRaids-v3\",\n  parsesByRaider: \"parsesByRaider-v3\",\n};\nObject.freeze(storageId);\n\nclass RaidsStore {\n  raidsToGetFightsFor = [];\n  parsesByRaider = {};\n  zones = {};\n\n  loading = true;\n  loadingBracketParses = true;\n  loadingOverallParses = true;\n  loadingZones = true;\n  needToGetData = false;\n  error = \"\";\n  timeRemaining = 0;\n\n  medianBracket = [];\n  bestBracket = [];\n  medianOverall = [];\n  bestOverall = [];\n\n  healerTypes = [\"Priest\", \"Paladin\", \"Druid\"];\n  healerExclusionList = [\"Lightsaber\", \"Neku\", \"Taede\"];\n  healers = [];\n  start;\n\n  /**\n   * Gets the name of the partition the parse data is grabbing from\n   * @returns {string} - the name of the partition\n   */\n  getPartitionName() {\n    return this.zone.partitions[partition].name;\n  }\n\n  /**\n   * Checks local storage to see if last seen raid data is up to date.\n   * If it's up to date this returns false otherwise true.\n   * @returns {boolean} - true when data needs updated, false otherwise\n   */\n  isRaidDataOutOfDate = () => {\n    const lastSeenRaids = JSON.parse(localStorage.getItem(storageId.lastSeenRaids));\n    let needToGetData = false;\n\n    if (!lastSeenRaids && this.raidsToGetFightsFor.length > 0) {\n      needToGetData = true;\n    } else {\n      this.raidsToGetFightsFor.forEach((id) => {\n        if (!lastSeenRaids.includes(id)) {\n          needToGetData = true;\n        }\n      });\n    }\n\n    return needToGetData;\n  };\n\n  /**\n   * Finds all the raiders from the collection of raid responses\n   * @param {array<object>} responses - array of multiple server responses\n   */\n  findRaiders = (responses) => {\n    const raidFights = [];\n    this.raids.forEach((raid) => {\n      responses.forEach((response) => {\n        if (raid.start === response.start && raid.title === response.title) {\n          raidFights.push(response);\n        }\n      });\n    });\n\n    raidFights.forEach((fight) => {\n      fight.exportedCharacters.forEach((char) => {\n        const friendlyData = fight.friendlies.find((e) => e.name === char.name);\n        if (\n          this.healerTypes.includes(friendlyData.type) &&\n          !this.healerExclusionList.includes(friendlyData.name) &&\n          !this.healers.includes(friendlyData.name)\n        ) {\n          this.healers.push(friendlyData.name);\n        }\n        this.parsesByRaider[char.name] = {};\n      });\n    });\n  };\n\n  /**\n   * Gets median and best parse data for a given raider\n   * @param {string} raider - the raider to organize parse data for\n   * @param {object} data - the parse data\n   */\n  getBossParseData(raider, data) {\n    const best = { name: raider };\n    const median = { name: raider };\n    if (data) {\n      Object.keys(data).forEach((bossKey) => {\n        const boss = data[bossKey];\n        let average = 0;\n        boss.parses.forEach((percentile) => {\n          average += percentile;\n        });\n        average /= boss.parses.length;\n        best[bossKey] = Number.isInteger(boss.best) ? boss.best : boss.best.toFixed(2);\n        median[bossKey] = Number.isNaN(average) ? \"-\" : Number.isInteger(average) ? average : average.toFixed(2);\n      });\n    }\n    return [median, best];\n  }\n\n  /**\n   * Handles the parse API responses.\n   * @param {array<object>} requests - the series of requests that were made\n   * @param {array<object>} raiders - the list of raiders\n   * @param {string} type - the type of parse (bracket or overall)\n   * @param {string} loadingVariableName - class variable name for loading\n   */\n  handleParseRequests = (requests, raiders, type, loadingVariableName) => {\n    const parseCutoff = this.start - 6 * weekInNanoSeconds;\n\n    setTimeout(() => {\n      axios\n        .all(requests)\n        .then(\n          axios.spread((...responses) => {\n            responses.forEach((response) => {\n              if (response[0]) {\n                const name = response[0].characterName;\n                this.parsesByRaider[name][type] = {};\n\n                response.forEach((encounter) => {\n                  const parses = this.parsesByRaider[name][type];\n                  if (!parses[encounter.encounterID]) {\n                    parses[encounter.encounterID] = {\n                      numberOfEncounters: 0,\n                      best: 0,\n                      parses: [],\n                    };\n                  }\n\n                  if (encounter.startTime > parseCutoff) {\n                    parses[encounter.encounterID].numberOfEncounters += 1;\n                    parses[encounter.encounterID].parses.push(encounter.percentile);\n                  }\n\n                  if (parses[encounter.encounterID].best < encounter.percentile) {\n                    parses[encounter.encounterID].best = encounter.percentile;\n                  }\n                });\n              }\n            });\n            this[loadingVariableName] = false;\n          })\n        )\n        .catch(() => {\n          this.error = apiError;\n          this[loadingVariableName] = false;\n        });\n    }, (raiders.length + 2) * requestDelay);\n  };\n\n  constructor() {\n    this.parsesByRaider = JSON.parse(localStorage.getItem(storageId.parsesByRaider)) ?? {};\n\n    this.start = Date.now();\n\n    request({ url: \"/zones\" }).then((response) => {\n      this.zones = response;\n      this.zone = this.zones.find((z) => z.name === zoneToGatherParsesFrom);\n      this.loadingZones = false;\n    });\n\n    // once we have zone data\n    reaction(\n      () => this.loadingZones,\n      () => {\n        request({\n          url: \"/reports/guild/RIVAL/Fairbanks/US\",\n        }).then((response) => {\n          this.raids = response;\n          // find last 4 weeks of raid data\n          this.raidsToGetFightsFor = response\n            .filter((raid) => raid.start > Date.now() - 4 * weekInNanoSeconds && raid.zone === this.zone.id)\n            .map((raid) => raid.id);\n          this.needToGetData = this.isRaidDataOutOfDate();\n\n          if (!this.needToGetData) {\n            this.loadingBracketParses = false;\n            this.loadingOverallParses = false;\n          }\n        });\n      }\n    );\n\n    // if raid data needs to be grabbed\n    reaction(\n      () => this.needToGetData,\n      () => {\n        const requests = [];\n        this.raidsToGetFightsFor.forEach((raidId) => {\n          requests.push(request({ url: `/report/fights/${raidId}` }));\n        });\n\n        axios.all(requests).then(\n          axios.spread((...responses) => {\n            this.findRaiders(responses);\n\n            const raiders = Object.keys(this.parsesByRaider);\n\n            const secondsRemaining = Math.floor(((raiders.length + 3) * requestDelay) / 1000);\n            this.timeRemaining = secondsRemaining;\n            for (let i = 0; i < secondsRemaining; i++) {\n              setTimeout(() => {\n                this.timeRemaining = this.timeRemaining - 1;\n              }, i * 1000);\n            }\n\n            const bracketRequests = [];\n            const overallRequests = [];\n\n            for (let i = 0; i < raiders.length; i++) {\n              setTimeout(() => {\n                const raider = raiders[i];\n                const url = `/parses/character/${raider}/Fairbanks/US`;\n                const zone = this.zone.id;\n                const metric = this.healers.includes(raider) ? \"hps\" : \"dps\";\n\n                bracketRequests.push(request({ url, params: { bracket: -1, zone, metric } }));\n                overallRequests.push(request({ url, params: { bracket: 0, zone, metric } }));\n              }, requestDelay * i);\n            }\n\n            this.handleParseRequests(bracketRequests, raiders, \"bracket\", \"loadingBracketParses\");\n            this.handleParseRequests(overallRequests, raiders, \"overall\", \"loadingOverallParses\");\n          })\n        );\n      }\n    );\n  }\n\n  finalizeParseData = reaction(\n    () => this.loadingBracketParses || this.loadingOverallParses || this.loadingZones,\n    () => {\n      if (!this.loadingBracketParses && !this.loadingOverallParses && !this.loadingZones) {\n        console.log(`done loading, time elapsed: ${(Date.now() - this.start) / 1000}s`);\n\n        const raiders = Object.keys(this.parsesByRaider).sort();\n        raiders.forEach((raider) => {\n          const { bracket, overall } = this.parsesByRaider[raider];\n\n          const [bracketMedian, bracketBest] = this.getBossParseData(raider, bracket);\n          const [overallMedian, overallBest] = this.getBossParseData(raider, overall);\n\n          this.bestBracket.push(bracketBest);\n          this.medianBracket.push(bracketMedian);\n          this.bestOverall.push(overallBest);\n          this.medianOverall.push(overallMedian);\n        });\n\n        this.loading = false;\n        localStorage.setItem(storageId.lastSeenRaids, JSON.stringify(this.raidsToGetFightsFor));\n        localStorage.setItem(storageId.parsesByRaider, JSON.stringify(this.parsesByRaider));\n      }\n    }\n  );\n}\n\ndecorate(RaidsStore, {\n  error: observable,\n  healers: observable,\n  loading: observable,\n  loadingBracketParses: observable,\n  loadingOverallParses: observable,\n  needToGetData: observable,\n  timeRemaining: observable,\n  loadingZones: observable,\n  bestBracket: observable,\n  medianBracket: observable,\n  bestOverall: observable,\n  medianOverall: observable,\n  zone: observable,\n});\n\nexport default RaidsStore;\n","import React from \"react\";\nimport RaidsStore from \"./raidsStore\";\n\nexport const storesContext = React.createContext({\n  raidStore: new RaidsStore(),\n});\n","import React from \"react\";\nimport { observer } from \"mobx-react\";\nimport { useStores } from \"hooks/useStores\";\n\nconst App = observer(() => {\n  const { raidStore } = useStores();\n\n  const getParseColor = (value) => {\n    let color = \"black\";\n    if (value === 100) {\n      color = \"#F4D03F\";\n    } else if (value >= 95 && value < 100) {\n      color = \"#F39C12\";\n    } else if (value >= 75 && value < 95) {\n      color = \"#8E44AD\";\n    } else if (value >= 50 && value < 75) {\n      color = \"#3498DB\";\n    } else if (value >= 25 && value < 50) {\n      color = \"#2ECC71\";\n    } else if (value >= 0 && value < 25) {\n      color = \"#BDC3C7\";\n    }\n    return color;\n  };\n\n  const generateTable = (data) => {\n    const { zone } = raidStore;\n\n    // generate header row\n    const headers = [\"Raider\", \"Average\"];\n    zone.encounters.forEach((encounter) => {\n      headers.push(encounter.name);\n    });\n\n    const rows = [];\n    data.forEach((raider) => {\n      const row = [raider.name];\n      const encounters = [];\n      let avg = 0;\n      let count = 0;\n      zone.encounters.forEach((encounter) => {\n        const value = raider[encounter.id] ?? \"-\";\n\n        if (value && value !== \"-\") {\n          avg += Number(value);\n          count += 1;\n        }\n\n        encounters.push(value);\n      });\n\n      if (avg !== 0) {\n        row.push((avg / count).toFixed(2));\n      } else {\n        row.push(\"-\");\n      }\n\n      encounters.forEach((encounter) => row.push(encounter));\n      rows.push(row);\n    });\n\n    return (\n      <table style={{ borderCollapse: \"collapse\", margin: \"3px 5px\" }}>\n        <thead>\n          <tr>\n            {headers.map((d) => (\n              <th\n                key={d}\n                style={{\n                  padding: \"5px\",\n                  textAlign: \"left\",\n                  fontWeight: \"bold\",\n                  backgroundColor: \"#5D6D7E\",\n                  color: \"white\",\n                  border: \"1px solid black\",\n                }}\n              >\n                {d}\n              </th>\n            ))}\n          </tr>\n        </thead>\n\n        <tbody>\n          {rows.map((row) => (\n            <tr>\n              {row.map((d) => (\n                <td style={{ padding: \"0px 5px\", border: \"1px solid black\", color: `${getParseColor(d)}` }}>{d}</td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    );\n  };\n\n  return (\n    <div>\n      {raidStore.loading ? (\n        <div>\n          <p style={{ margin: \"5px\" }}>Due to WarcraftLog's API request limit, loading will take about 2 minutes.</p>\n          {raidStore.timeRemaining > 0 && (\n            <p style={{ margin: \"5px\" }}>{`Estimated time remaining: ${raidStore.timeRemaining}s`}</p>\n          )}\n        </div>\n      ) : raidStore.error !== \"\" ? (\n        `ERROR: ${raidStore.error}`\n      ) : (\n        <div>\n          <p style={{ margin: \"5px 0px 5px 5px\" }}>\n            <b>Zone:</b>\n            {` ${raidStore.zone.name}`}\n          </p>\n          <p style={{ margin: \"0px 5px\" }}>\n            <b>Partition:</b>\n            {` ${raidStore.getPartitionName()}`}\n          </p>\n          <p style={{ margin: \"5px\" }}>\n            <b>Details:</b>\n            {` Druids, Paladins, and Priests have healing parses pulled. The following people are excluded from that: ${raidStore.healerExclusionList\n              .sort()\n              .join(\", \")}`}\n          </p>\n          <p style={{ margin: \"15px 5px 7px 5px\" }}>\n            <b>Median Bracket:</b>\n          </p>\n          {generateTable(raidStore.medianBracket)}\n          <p style={{ margin: \"7px 5px\" }}>\n            <b>Best Bracket:</b>\n          </p>\n          {generateTable(raidStore.bestBracket)}\n          <p style={{ margin: \"7px 5px\" }}>\n            <b>Median Overall:</b>\n          </p>\n          {generateTable(raidStore.medianOverall)}\n          <p style={{ margin: \"7px 5px\" }}>\n            <b>Best Overall:</b>\n          </p>\n          {generateTable(raidStore.bestOverall)}\n        </div>\n      )}\n    </div>\n  );\n});\n\nexport default App;\n","import React from 'react'\nimport { storesContext } from 'stores'\n\nexport const useStores = () => React.useContext(storesContext);","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}